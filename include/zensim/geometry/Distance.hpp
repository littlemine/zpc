#pragma once
#include "zensim/math/VecInterface.hpp"

namespace zs {

  /// ref: ipc-sim/Codim-IPC, Math/Distance/EDGE_EDGE.h
  //
  //! point-point
  //
  template <
      typename VecTA, typename VecTB,
      enable_if_all<VecTA::dim == 1, is_same_v<typename VecTA::dims, typename VecTB::dims>> = 0>
  constexpr auto dist2_pp(const VecInterface<VecTA> &a, const VecInterface<VecTB> &b) noexcept {
    return (b - a).l2NormSqr();
  }
  template <
      typename VecTA, typename VecTB,
      enable_if_all<VecTA::dim == 1, is_same_v<typename VecTA::dims, typename VecTB::dims>> = 0>
  constexpr auto dist_pp(const VecInterface<VecTA> &a, const VecInterface<VecTB> &b) noexcept {
    return zs::sqrt(dist2_pp(a, b));
  }

  template <
      typename VecTA, typename VecTB,
      enable_if_all<VecTA::dim == 1, is_same_v<typename VecTA::dims, typename VecTB::dims>> = 0>
  constexpr auto dist_grad_pp(const VecInterface<VecTA> &a, const VecInterface<VecTB> &b) noexcept {
    using T = math::op_result_t<typename VecTA::value_type, typename VecTB::value_type>;
    using Ti = typename VecTA::index_type;
    constexpr int dim = VecTA::extent;
    using RetT = typename VecTA::template variant_vec<T, integer_seq<Ti, 2, dim>>;
    RetT ret{};
    for (int d = 0; d != dim; ++d) {
      auto v = 2 * (a(d) - b(d));
      ret(0, d) = v;
      ret(1, d) = -v;
    }
    return ret;
  }

  //
  //! point-edge
  //
  namespace detail {
    template <class T, typename VecT>
    constexpr void g_PE2D(T v01, T v02, T v11, T v12, T v21, T v22, VecInterface<VecT> &g) {
      T t13{};
      T t14{};
      T t23{};
      T t25{};
      T t24{};
      T t26{};
      T t27{};

      /* G_PE2D */
      /*     G = G_PE2D(V01,V02,V11,V12,V21,V22) */
      /*     This function was generated by the Symbolic Math Toolbox version 8.3. */
      /*     16-Mar-2020 15:56:29 */
      t13 = -v21 + v11;
      t14 = -v22 + v12;
      t23 = 1.0 / (t13 * t13 + t14 * t14);
      t25 = ((v11 * v22 + -(v12 * v21)) + t14 * v01) + -(t13 * v02);
      t24 = t23 * t23;
      t26 = t25 * t25;
      t27 = (v11 * 2.0 + -(v21 * 2.0)) * t24 * t26;
      t26 *= (v12 * 2.0 + -(v22 * 2.0)) * t24;
      g.val(0) = t14 * t23 * t25 * 2.0;
      g.val(1) = t13 * t23 * t25 * -2.0;
      t24 = t23 * t25;
      g.val(2) = -t27 - t24 * (-v22 + v02) * 2.0;
      g.val(3) = -t26 + t24 * (-v21 + v01) * 2.0;
      g.val(4) = t27 + t24 * (v02 - v12) * 2.0;
      g.val(5) = t26 - t24 * (v01 - v11) * 2.0;
    }

    template <class T, typename VecT> constexpr void g_PE3D(T v01, T v02, T v03, T v11, T v12,
                                                            T v13, T v21, T v22, T v23,
                                                            VecInterface<VecT> &g) {
      T t17{};
      T t18{};
      T t19{};
      T t20{};
      T t21{};
      T t22{};
      T t23{};
      T t24{};
      T t25{};
      T t42{};
      T t44{};
      T t45{};
      T t46{};
      T t43{};
      T t50{};
      T t51{};
      T t52{};

      /* G_PE */
      /*     G = G_PE(V01,V02,V03,V11,V12,V13,V21,V22,V23) */
      /*     This function was generated by the Symbolic Math Toolbox version 8.3. */
      /*     10-Jun-2019 18:02:37 */
      t17 = -v11 + v01;
      t18 = -v12 + v02;
      t19 = -v13 + v03;
      t20 = -v21 + v01;
      t21 = -v22 + v02;
      t22 = -v23 + v03;
      t23 = -v21 + v11;
      t24 = -v22 + v12;
      t25 = -v23 + v13;
      t42 = 1.0 / ((t23 * t23 + t24 * t24) + t25 * t25);
      t44 = t17 * t21 + -(t18 * t20);
      t45 = t17 * t22 + -(t19 * t20);
      t46 = t18 * t22 + -(t19 * t21);
      t43 = t42 * t42;
      t50 = (t44 * t44 + t45 * t45) + t46 * t46;
      t51 = (v11 * 2.0 + -(v21 * 2.0)) * t43 * t50;
      t52 = (v12 * 2.0 + -(v22 * 2.0)) * t43 * t50;
      t43 = (v13 * 2.0 + -(v23 * 2.0)) * t43 * t50;
      g.val(0) = t42 * (t24 * t44 * 2.0 + t25 * t45 * 2.0);
      g.val(1) = -t42 * (t23 * t44 * 2.0 - t25 * t46 * 2.0);
      g.val(2) = -t42 * (t23 * t45 * 2.0 + t24 * t46 * 2.0);
      g.val(3) = -t51 - t42 * (t21 * t44 * 2.0 + t22 * t45 * 2.0);
      g.val(4) = -t52 + t42 * (t20 * t44 * 2.0 - t22 * t46 * 2.0);
      g.val(5) = -t43 + t42 * (t20 * t45 * 2.0 + t21 * t46 * 2.0);
      g.val(6) = t51 + t42 * (t18 * t44 * 2.0 + t19 * t45 * 2.0);
      g.val(7) = t52 - t42 * (t17 * t44 * 2.0 - t19 * t46 * 2.0);
      g.val(8) = t43 - t42 * (t17 * t45 * 2.0 + t18 * t46 * 2.0);
    }
  }  // namespace detail

  template <
      typename VecTP, typename VecTE,
      enable_if_all<VecTP::dim == 1, is_same_v<typename VecTP::dims, typename VecTE::dims>> = 0>
  constexpr int pe_distance_type(const VecInterface<VecTP> &p, const VecInterface<VecTE> &e0,
                                 const VecInterface<VecTE> &e1) noexcept {
    const auto e = e1 - e0;
    auto indicator = e.dot(p - e0) / e.l2NormSqr();
    return indicator < 0 ? 0 : (indicator > 1 ? 1 : 2);
  }

  template <
      typename VecTP, typename VecTE,
      enable_if_all<VecTP::dim == 1, is_same_v<typename VecTP::dims, typename VecTE::dims>> = 0>
  constexpr auto dist2_pe(const VecInterface<VecTP> &p, const VecInterface<VecTE> &e0,
                          const VecInterface<VecTE> &e1) noexcept {
    using T = math::op_result_t<typename VecTP::value_type, typename VecTE::value_type>;
    constexpr int dim = VecTP::extent;
    T dist2{0};
    if constexpr (dim == 1) {
      auto d0 = p[0] - e0[0];
      auto d1 = p[0] - e1[0];
      dist2 = d0 * d1 < 0 ? 0 : zs::min(d0 * d0, d1 * d1);
    } else if constexpr (dim == 2) {
      auto e = e1 - e0;
      auto numerator = (e[1] * p[0] - e[0] * p[1] + e1[0] * e0[1] - e1[1] * e0[0]);
      dist2 = numerator * numerator / e.l2NormSqr();
    } else if constexpr (dim == 3)
      dist2 = (e0 - p).cross(e1 - p).l2NormSqr() / (e1 - e0).l2NormSqr();
    return dist2;
  }

  template <
      typename VecTP, typename VecTE,
      enable_if_all<VecTP::dim == 1, is_same_v<typename VecTP::dims, typename VecTE::dims>> = 0>
  constexpr auto dist2_pe_unclassified(const VecInterface<VecTP> &p, const VecInterface<VecTE> &e0,
                                       const VecInterface<VecTE> &e1) noexcept {
    using T = math::op_result_t<typename VecTP::value_type, typename VecTE::value_type>;
    constexpr int dim = VecTP::extent;
    T ret = limits<T>::max();
    switch (pe_distance_type(p, e0, e1)) {
      case 0:
        ret = dist2_pp(p, e0);
        break;
      case 1:
        ret = dist2_pp(p, e1);
        break;
      case 2:
        if constexpr (dim == 2) {
          const auto e = e1 - e0;
          auto numerator = e[1] * p[0] - e[0] * p[1] + e1[0] * e0[1] - e1[1] * e0[0];
          ret = numerator * numerator / e.l2NormSqr();
        } else if constexpr (dim == 3) {
          ret = cross(e0 - p, e1 - p).l2NormSqr() / (e1 - e0).l2NormSqr();
        }
        break;
      default:
        break;
    }
    return ret;
  }
  template <
      typename VecTP, typename VecTE,
      enable_if_all<VecTP::dim == 1, is_same_v<typename VecTP::dims, typename VecTE::dims>> = 0>
  constexpr auto dist_pe_unclassified(const VecInterface<VecTP> &p, const VecInterface<VecTE> &e0,
                                      const VecInterface<VecTE> &e1) noexcept {
    return zs::sqrt(dist2_pe_unclassified(p, e0, e1));
  }

  template <
      typename VecTP, typename VecTE,
      enable_if_all<VecTP::dim == 1, is_same_v<typename VecTP::dims, typename VecTE::dims>> = 0>
  constexpr auto dist_grad_pe(const VecInterface<VecTP> &p, const VecInterface<VecTE> &e0,
                              const VecInterface<VecTE> &e1) noexcept {
    using T = math::op_result_t<typename VecTP::value_type, typename VecTE::value_type>;
    using Ti = typename VecTP::index_type;
    constexpr int dim = VecTP::extent;
    static_assert(dim == 3 || dim == 2, "currently only implement 2d/3d version");
    using RetT = typename VecTP::template variant_vec<T, integer_seq<Ti, 3, dim>>;
    RetT ret{};
    if constexpr (dim == 2)
      detail::g_PE2D(p[0], p[1], e0[0], e0[1], e1[0], e1[1], ret);
    else if constexpr (dim == 3)
      detail::g_PE3D(p[0], p[1], p[2], e0[0], e0[1], e0[2], e1[0], e1[1], e1[2], ret);
    return ret;
  }

  //
  //! edge-edge
  //
  namespace detail {
    template <class T, typename VecT> constexpr void g_EE(T v01, T v02, T v03, T v11, T v12, T v13,
                                                          T v21, T v22, T v23, T v31, T v32, T v33,
                                                          VecInterface<VecT> &g) noexcept {
      T t11{};
      T t12{};
      T t13{};
      T t14{};
      T t15{};
      T t16{};
      T t17{};
      T t18{};
      T t19{};
      T t32{};
      T t33{};
      T t34{};
      T t35{};
      T t36{};
      T t37{};
      T t44{};
      T t45{};
      T t46{};
      T t75{};
      T t77{};
      T t76{};
      T t78{};
      T t79{};
      T t80{};
      T t81{};
      T t83{};

      /* G_EE */
      /*     G = G_EE(V01,V02,V03,V11,V12,V13,V21,V22,V23,V31,V32,V33) */
      /*     This function was generated by the Symbolic Math Toolbox version 8.3. */
      /*     14-Jun-2019 13:58:25 */
      t11 = -v11 + v01;
      t12 = -v12 + v02;
      t13 = -v13 + v03;
      t14 = -v21 + v01;
      t15 = -v22 + v02;
      t16 = -v23 + v03;
      t17 = -v31 + v21;
      t18 = -v32 + v22;
      t19 = -v33 + v23;
      t32 = t14 * t18;
      t33 = t15 * t17;
      t34 = t14 * t19;
      t35 = t16 * t17;
      t36 = t15 * t19;
      t37 = t16 * t18;
      t44 = t11 * t18 + -(t12 * t17);
      t45 = t11 * t19 + -(t13 * t17);
      t46 = t12 * t19 + -(t13 * t18);
      t75 = 1.0 / ((t44 * t44 + t45 * t45) + t46 * t46);
      t77 = (t16 * t44 + t14 * t46) + -(t15 * t45);
      t76 = t75 * t75;
      t78 = t77 * t77;
      t79 = (t12 * t44 * 2.0 + t13 * t45 * 2.0) * t76 * t78;
      t80 = (t11 * t45 * 2.0 + t12 * t46 * 2.0) * t76 * t78;
      t81 = (t18 * t44 * 2.0 + t19 * t45 * 2.0) * t76 * t78;
      t18 = (t17 * t45 * 2.0 + t18 * t46 * 2.0) * t76 * t78;
      t83 = (t11 * t44 * 2.0 + -(t13 * t46 * 2.0)) * t76 * t78;
      t19 = (t17 * t44 * 2.0 + -(t19 * t46 * 2.0)) * t76 * t78;
      t76 = t75 * t77;
      g.val(0) = -t81 + t76 * ((-t36 + t37) + t46) * 2.0;
      g.val(1) = t19 - t76 * ((-t34 + t35) + t45) * 2.0;
      g.val(2) = t18 + t76 * ((-t32 + t33) + t44) * 2.0;
      g.val(3) = t81 + t76 * (t36 - t37) * 2.0;
      g.val(4) = -t19 - t76 * (t34 - t35) * 2.0;
      g.val(5) = -t18 + t76 * (t32 - t33) * 2.0;
      t17 = t12 * t16 + -(t13 * t15);
      g.val(6) = t79 - t76 * (t17 + t46) * 2.0;
      t18 = t11 * t16 + -(t13 * t14);
      g.val(7) = -t83 + t76 * (t18 + t45) * 2.0;
      t19 = t11 * t15 + -(t12 * t14);
      g.val(8) = -t80 - t76 * (t19 + t44) * 2.0;
      g.val(9) = -t79 + t76 * t17 * 2.0;
      g.val(10) = t83 - t76 * t18 * 2.0;
      g.val(11) = t80 + t76 * t19 * 2.0;
    }
  }  // namespace detail

  template <typename VecTA, typename VecTB>
  constexpr int ee_distance_type(const VecInterface<VecTA> &ea0, const VecInterface<VecTA> &ea1,
                                 const VecInterface<VecTB> &eb0, const VecInterface<VecTB> &eb1) {
    using T = math::op_result_t<typename VecTA::value_type, typename VecTB::value_type>;
    auto u = ea1 - ea0;
    auto v = eb1 - eb0;
    auto w = ea0 - eb0;
    T a = u.l2NormSqr();  // always >= 0
    T b = u.dot(v);
    T c = v.l2NormSqr();  // always >= 0
    T d = u.dot(w);
    T e = v.dot(w);
    T D = a * c - b * b;  // always >= 0
    T tD = D;             // tc = tN / tD, default tD = D >= 0
    T sN{}, tN{};

    int defaultCase = 8;

    // compute the line parameters of the two closest points
    sN = (b * e - c * d);
    if (sN <= 0.0) {  // sc < 0 => the s=0 edge is visible
      tN = e;
      tD = c;
      defaultCase = 2;
    } else if (sN >= D) {  // sc > 1  => the s=1 edge is visible
      tN = e + b;
      tD = c;
      defaultCase = 5;
    } else {
      tN = (a * e - b * d);
      if (tN > 0.0 && tN < tD
          && (u.cross(v).dot(w) == 0.0 || u.cross(v).l2NormSqr() < 1.0e-20 * a * c)) {
        if (sN < D / 2) {
          tN = e;
          tD = c;
          defaultCase = 2;
        } else {
          tN = e + b;
          tD = c;
          defaultCase = 5;
        }
      }
      // else defaultCase stays as 8
    }

    if (tN <= 0.0) {  // tc < 0 => the t=0 edge is visible
      // recompute sc for this edge
      if (-d <= 0.0) {
        return 0;
      } else if (-d >= a) {
        return 3;
      } else {
        return 6;
      }
    } else if (tN >= tD) {  // tc > 1  => the t=1 edge is visible
      // recompute sc for this edge
      if ((-d + b) <= 0.0) {
        return 1;
      } else if ((-d + b) >= a) {
        return 4;
      } else {
        return 7;
      }
    }

    return defaultCase;
  }

  template <
      typename VecTA, typename VecTB,
      enable_if_all<VecTA::dim == 1, is_same_v<typename VecTA::dims, typename VecTB::dims>> = 0>
  constexpr auto dist2_ee(const VecInterface<VecTA> &ea0, const VecInterface<VecTA> &ea1,
                          const VecInterface<VecTB> &eb0, const VecInterface<VecTB> &eb1) noexcept {
    using T = math::op_result_t<typename VecTA::value_type, typename VecTB::value_type>;
    auto b = (ea1 - ea0).cross(eb1 - eb0);
    T aTb = (eb0 - ea0).dot(b);
    return aTb * aTb / b.l2NormSqr();
  }

  template <
      typename VecTA, typename VecTB,
      enable_if_all<VecTA::dim == 1, is_same_v<typename VecTA::dims, typename VecTB::dims>> = 0>
  constexpr auto dist2_ee_unclassified(const VecInterface<VecTA> &ea0,
                                       const VecInterface<VecTA> &ea1,
                                       const VecInterface<VecTB> &eb0,
                                       const VecInterface<VecTB> &eb1) noexcept {
    using T = math::op_result_t<typename VecTA::value_type, typename VecTB::value_type>;
    T dist2{limits<T>::max()};
    switch (ee_distance_type(ea0, ea1, eb0, eb1)) {
      case 0:
        dist2 = dist2_pp(ea0, eb0);
        break;
      case 1:
        dist2 = dist2_pp(ea0, eb1);
        break;
      case 2:
        dist2 = dist2_pe(ea0, eb0, eb1);
        break;
      case 3:
        dist2 = dist2_pp(ea1, eb0);
        break;
      case 4:
        dist2 = dist2_pp(ea1, eb1);
        break;
      case 5:
        dist2 = dist2_pe(ea1, eb0, eb1);
        break;
      case 6:
        dist2 = dist2_pe(eb0, ea0, ea1);
        break;
      case 7:
        dist2 = dist2_pe(eb1, ea0, ea1);
        break;
      case 8:
        dist2 = dist2_ee(ea0, ea1, eb0, eb1);
        break;
      default:
        break;
    }
    return dist2;
  }

  template <
      typename VecTA, typename VecTB,
      enable_if_all<VecTA::dim == 1, is_same_v<typename VecTA::dims, typename VecTB::dims>> = 0>
  constexpr auto dist_ee_unclassified(const VecInterface<VecTA> &ea0,
                                      const VecInterface<VecTA> &ea1,
                                      const VecInterface<VecTB> &eb0,
                                      const VecInterface<VecTB> &eb1) noexcept {
    return zs::sqrt(dist2_ee_unclassified(ea0, ea1, eb0, eb1));
  }

  template <
      typename VecTA, typename VecTB,
      enable_if_all<VecTA::dim == 1, is_same_v<typename VecTA::dims, typename VecTB::dims>> = 0>
  constexpr auto dist_grad_ee(const VecInterface<VecTA> &ea0, const VecInterface<VecTA> &ea1,
                              const VecInterface<VecTB> &eb0,
                              const VecInterface<VecTB> &eb1) noexcept {
    using T = math::op_result_t<typename VecTA::value_type, typename VecTB::value_type>;
    using Ti = typename VecTA::index_type;
    constexpr int dim = VecTA::template range_t<0>::value;
    static_assert(dim == 3, "currently only implement 3d version");
    using RetT = typename VecTA::template variant_vec<T, integer_seq<Ti, 4, dim>>;
    RetT ret{};
    detail::g_EE(ea0[0], ea0[1], ea0[2], ea1[0], ea1[1], ea1[2], eb0[0], eb0[1], eb0[2], eb1[0],
                 eb1[1], eb1[2], ret);
    return ret;
  }

  //
  //! point-triangle
  //
  namespace detail {
    template <class T, typename VecT> constexpr void g_PT(T v01, T v02, T v03, T v11, T v12, T v13,
                                                          T v21, T v22, T v23, T v31, T v32, T v33,
                                                          VecInterface<VecT> &g) noexcept {
      T t11{};
      T t12{};
      T t13{};
      T t14{};
      T t15{};
      T t16{};
      T t17{};
      T t18{};
      T t19{};
      T t20{};
      T t21{};
      T t22{};
      T t32{};
      T t33{};
      T t34{};
      T t43{};
      T t45{};
      T t44{};
      T t46{};

      /* G_PT */
      /*     G = G_PT(V01,V02,V03,V11,V12,V13,V21,V22,V23,V31,V32,V33) */
      /*     This function was generated by the Symbolic Math Toolbox version 8.3. */
      /*     10-Jun-2019 17:42:16 */
      t11 = -v11 + v01;
      t12 = -v12 + v02;
      t13 = -v13 + v03;
      t14 = -v21 + v11;
      t15 = -v22 + v12;
      t16 = -v23 + v13;
      t17 = -v31 + v11;
      t18 = -v32 + v12;
      t19 = -v33 + v13;
      t20 = -v31 + v21;
      t21 = -v32 + v22;
      t22 = -v33 + v23;
      t32 = t14 * t18 + -(t15 * t17);
      t33 = t14 * t19 + -(t16 * t17);
      t34 = t15 * t19 + -(t16 * t18);
      t43 = 1.0 / ((t32 * t32 + t33 * t33) + t34 * t34);
      t45 = (t13 * t32 + t11 * t34) + -(t12 * t33);
      t44 = t43 * t43;
      t46 = t45 * t45;
      g.val(0) = t34 * t43 * t45 * 2.0;
      g.val(1) = t33 * t43 * t45 * -2.0;
      g.val(2) = t32 * t43 * t45 * 2.0;
      t45 *= t43;
      g.val(3) = -t44 * t46 * (t21 * t32 * 2.0 + t22 * t33 * 2.0)
                 - t45 * ((t34 + t12 * t22) - t13 * t21) * 2.0;
      t43 = t44 * t46;
      g.val(4)
          = t43 * (t20 * t32 * 2.0 - t22 * t34 * 2.0) + t45 * ((t33 + t11 * t22) - t13 * t20) * 2.0;
      g.val(5)
          = t43 * (t20 * t33 * 2.0 + t21 * t34 * 2.0) - t45 * ((t32 + t11 * t21) - t12 * t20) * 2.0;
      g.val(6) = t45 * (t12 * t19 - t13 * t18) * 2.0 + t43 * (t18 * t32 * 2.0 + t19 * t33 * 2.0);
      g.val(7) = t45 * (t11 * t19 - t13 * t17) * -2.0 - t43 * (t17 * t32 * 2.0 - t19 * t34 * 2.0);
      g.val(8) = t45 * (t11 * t18 - t12 * t17) * 2.0 - t43 * (t17 * t33 * 2.0 + t18 * t34 * 2.0);
      g.val(9) = t45 * (t12 * t16 - t13 * t15) * -2.0 - t43 * (t15 * t32 * 2.0 + t16 * t33 * 2.0);
      g.val(10) = t45 * (t11 * t16 - t13 * t14) * 2.0 + t43 * (t14 * t32 * 2.0 - t16 * t34 * 2.0);
      g.val(11) = t45 * (t11 * t15 - t12 * t14) * -2.0 + t43 * (t14 * t33 * 2.0 + t15 * t34 * 2.0);
    }
  }  // namespace detail

  template <typename VecTP, typename VecT>
  constexpr int pt_distance_type(const VecInterface<VecTP> &p, const VecInterface<VecT> &t0,
                                 const VecInterface<VecT> &t1, const VecInterface<VecT> &t2) {
    using T = math::op_result_t<typename VecTP::value_type, typename VecT::value_type>;
    constexpr int dim = VecTP::extent;
    using Ti = typename VecTP::index_type;

    typename VecTP::template variant_vec<T, integer_seq<Ti, 2, dim>> basis{};
    for (int d = 0; d != dim; ++d) {
      basis(0, d) = t1(d) - t0(d);
      basis(1, d) = t2(d) - t0(d);
    }

    const auto nVec = row(basis, 0).cross(row(basis, 1));

    typename VecTP::template variant_vec<T, integer_seq<Ti, 2, dim>> param{};

    {
      auto tmp = row(basis, 0).cross(nVec);
      for (int d = 0; d != dim; ++d) basis(1, d) = tmp(d);
    }
    {
      {
        // param.col(0) = (basis * basis.transpose()).ldlt().solve(basis * (p - t0));
        auto tmp = inverse(basis * basis.transpose()) * (basis * (p - t0));
        for (int d = 0; d != 2; ++d) param(d, 0) = tmp(d);
      }

      if (param(0, 0) > 0.0 && param(0, 0) < 1.0 && param(1, 0) >= 0.0) {
        return 3;  // PE t0t1
      } else {
        {
          // basis.row(0) = (t2 - t1).transpose();
          // basis.row(1) = basis.row(0).cross(nVec);
          auto tmp = t2 - t1;
          auto tmp1 = tmp.cross(nVec);
          for (int d = 0; d != dim; ++d) {
            basis(0, d) = tmp(d);
            basis(1, d) = tmp1(d);
          }
        }
        {
          // param.col(1) = (basis * basis.transpose()).ldlt().solve(basis * (p - t1));
          auto tmp = inverse(basis * basis.transpose()) * (basis * (p - t1));
          for (int d = 0; d != 2; ++d) param(d, 1) = tmp(d);
        }
        if (param(0, 1) > 0.0 && param(0, 1) < 1.0 && param(1, 1) >= 0.0) {
          return 4;  // PE t1t2
        } else {
          {
            // basis.row(0) = (t0 - t2).transpose();
            // basis.row(1) = basis.row(0).cross(nVec);
            auto tmp = t0 - t2;
            auto tmp1 = tmp.cross(nVec);
            for (int d = 0; d != dim; ++d) {
              basis(0, d) = tmp(d);
              basis(1, d) = tmp1(d);
            }
          }
          {
            // param.col(2) = (basis * basis.transpose()).ldlt().solve(basis * (p - t2));
            auto tmp = inverse(basis * basis.transpose()) * (basis * (p - t2));
            for (int d = 0; d != 2; ++d) param(d, 2) = tmp(d);
          }
          if (param(0, 2) > 0.0 && param(0, 2) < 1.0 && param(1, 2) >= 0.0)
            return 5;  // PE t2t0
          else {
            if (param(0, 0) <= 0.0 && param(0, 2) >= 1.0)
              return 0;  // PP t0
            else if (param(0, 1) <= 0.0 && param(0, 0) >= 1.0)
              return 1;  // PP t1
            else if (param(0, 2) <= 0.0 && param(0, 1) >= 1.0)
              return 2;  // PP t2
            else
              return 6;  // PT
          }
        }
      }
      return -1;
    }
  }

  template <
      typename VecTP, typename VecT,
      enable_if_all<VecTP::dim == 1, is_same_v<typename VecTP::dims, typename VecT::dims>> = 0>
  constexpr auto dist2_pt(const VecInterface<VecTP> &p, const VecInterface<VecT> &t0,
                          const VecInterface<VecT> &t1, const VecInterface<VecT> &t2) noexcept {
    using T = math::op_result_t<typename VecTP::value_type, typename VecT::value_type>;
    auto b = (t1 - t0).cross(t2 - t0);
    T aTb = (p - t0).dot(b);
    return aTb * aTb / b.l2NormSqr();
  }

  template <
      typename VecTP, typename VecT,
      enable_if_all<VecTP::dim == 1, is_same_v<typename VecTP::dims, typename VecT::dims>> = 0>
  constexpr auto dist2_pt_unclassified(const VecInterface<VecTP> &p, const VecInterface<VecT> &t0,
                                       const VecInterface<VecT> &t1,
                                       const VecInterface<VecT> &t2) noexcept {
    using T = math::op_result_t<typename VecTP::value_type, typename VecT::value_type>;
    T dist2{limits<T>::max()};
    switch (pt_distance_type(p, t0, t1, t2)) {
      case 0:
        dist2 = dist2_pp(p, t0);
        break;
      case 1:
        dist2 = dist2_pp(p, t1);
        break;
      case 2:
        dist2 = dist2_pp(p, t2);
        break;
      case 3:
        dist2 = dist2_pe(p, t0, t1);
        break;
      case 4:
        dist2 = dist2_pe(p, t1, t2);
        break;
      case 5:
        dist2 = dist2_pe(p, t2, t0);
        break;
      case 6:
        dist2 = dist2_pt(p, t0, t1, t2);
        break;
      default:
        break;
    }
    return dist2;
  }

  template <
      typename VecTP, typename VecT,
      enable_if_all<VecTP::dim == 1, is_same_v<typename VecTP::dims, typename VecT::dims>> = 0>
  constexpr auto dist_pt_unclassified(const VecInterface<VecTP> &p, const VecInterface<VecT> &t0,
                                      const VecInterface<VecT> &t1,
                                      const VecInterface<VecT> &t2) noexcept {
    return zs::sqrt(dist2_pt_unclassified(p, t0, t1, t2));
  }

  template <
      typename VecTP, typename VecT,
      enable_if_all<VecTP::dim == 1, is_same_v<typename VecTP::dims, typename VecT::dims>> = 0>
  constexpr auto dist_grad_pt(const VecInterface<VecTP> &p, const VecInterface<VecT> &t0,
                              const VecInterface<VecT> &t1, const VecInterface<VecT> &t2) noexcept {
    using T = math::op_result_t<typename VecTP::value_type, typename VecT::value_type>;
    using Ti = typename VecTP::index_type;
    constexpr int dim = VecTP::extent;
    static_assert(dim == 3, "currently only implement 3d version");
    using RetT = typename VecTP::template variant_vec<T, integer_seq<Ti, 4, dim>>;
    RetT ret{};
    detail::g_PT(p[0], p[1], p[2], t0[0], t0[1], t0[2], t1[0], t1[1], t1[2], t2[0], t2[1], t2[2],
                 ret);
    return ret;
  }

}  // namespace zs